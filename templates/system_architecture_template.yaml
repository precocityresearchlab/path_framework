# System Architecture Template
# Phase 1: PATH-Based Software Engineering
# Use this template to document your system architecture design

# PROJECT INFORMATION
project:
  name: "Your Project Name"
  version: "1.0.0"
  description: "Brief project description"
  domain: "business|protocol|data|realtime"  # Choose primary domain
  
# ARCHITECTURE PATTERN SELECTION
architecture:
  pattern: "clean|hexagonal|microservices|event-driven|modular-monolith"  # Choose primary pattern
  justification: |
    Explanation of why this pattern was selected:
    - Requirement alignment
    - Trade-off analysis
    - Future scalability considerations
  
  alternatives_considered:
    - pattern: "alternative-pattern-1"
      pros: ["benefit1", "benefit2"]
      cons: ["limitation1", "limitation2"]
      decision: "reason for rejection"

# SYSTEM STRUCTURE
system:
  layers:
    presentation:
      description: "User interface and API layer"
      components: ["api-controllers", "web-ui", "mobile-app"]
      responsibilities: ["HTTP handling", "input validation", "response formatting"]
      
    application:
      description: "Business logic orchestration"
      components: ["use-cases", "services", "workflows"]
      responsibilities: ["business rules", "coordination", "validation"]
      
    domain:
      description: "Core business entities and rules"
      components: ["entities", "value-objects", "domain-services"]
      responsibilities: ["business invariants", "domain logic", "business validation"]
      
    infrastructure:
      description: "External integrations and persistence"
      components: ["repositories", "external-apis", "messaging"]
      responsibilities: ["data persistence", "external communication", "infrastructure concerns"]

# TECHNOLOGY STACK
technology:
  runtime:
    language: "go|java|python|javascript|typescript|csharp|rust"
    version: "specific version"
    framework: "framework name and version"
    
  database:
    primary: "postgresql|mysql|mongodb|redis"
    version: "specific version"
    connection_pool: "connection pooling strategy"
    
  messaging:
    system: "kafka|rabbitmq|nats|sqs|none"
    patterns: ["pub-sub", "request-reply", "event-sourcing"]
    
  caching:
    system: "redis|memcached|in-memory|none"
    strategy: "cache-aside|write-through|write-behind"
    
  external_apis:
    - name: "api-name"
      purpose: "integration purpose"
      protocol: "REST|GraphQL|gRPC|MQTT|WebSocket"

# SCALABILITY DESIGN
scalability:
  current_targets:
    concurrent_users: 1000
    requests_per_second: 5000
    data_volume: "100GB"
    
  future_targets:
    concurrent_users: 10000
    requests_per_second: 50000
    data_volume: "1TB"
    
  scaling_strategy:
    horizontal: "component scaling approach"
    vertical: "resource scaling limits"
    database: "database scaling strategy"
    
# QUALITY ATTRIBUTES
quality_attributes:
  performance:
    response_time: "< 200ms average"
    throughput: "5000 requests/second"
    
  reliability:
    uptime: "99.9%"
    mtbf: "720 hours"
    mttr: "< 4 hours"
    
  security:
    authentication: "JWT|OAuth2|SAML"
    authorization: "RBAC|ABAC|custom"
    encryption: "TLS 1.3, AES-256"
    
  maintainability:
    code_coverage: "> 90%"
    cyclomatic_complexity: "< 10"
    test_automation: "100% critical paths"

# COMPONENT RELATIONSHIPS
dependencies:
  external:
    - name: "external-service-1"
      type: "REST API"
      criticality: "high|medium|low"
      fallback: "fallback strategy"
      
  internal:
    - from: "component-a"
      to: "component-b"
      type: "synchronous|asynchronous|event"
      protocol: "HTTP|gRPC|message-queue"

# DEPLOYMENT ARCHITECTURE
deployment:
  environment_strategy: "dev|staging|prod environments"
  container_strategy: "docker|kubernetes|serverless"
  database_strategy: "single|read-replicas|sharding"
  
  environments:
    development:
      instances: 1
      resources: "minimal"
      
    staging:
      instances: 2
      resources: "production-like"
      
    production:
      instances: 3
      resources: "high-availability"

# MONITORING AND OBSERVABILITY
observability:
  metrics:
    - "business metrics (conversion, usage)"
    - "application metrics (response time, errors)"
    - "infrastructure metrics (CPU, memory, disk)"
    
  logging:
    - "application logs (structured JSON)"
    - "access logs (HTTP requests)"
    - "audit logs (security events)"
    
  tracing:
    - "distributed tracing across services"
    - "database query tracing"
    - "external API call tracing"

# SECURITY CONSIDERATIONS
security:
  authentication:
    mechanism: "JWT|OAuth2|API-keys"
    token_expiry: "token lifetime"
    
  authorization:
    model: "RBAC|ABAC|custom"
    granularity: "api-level|resource-level|field-level"
    
  data_protection:
    encryption_at_rest: "database encryption strategy"
    encryption_in_transit: "TLS configuration"
    sensitive_data: "PII handling strategy"
    
  audit:
    events: ["login", "data-access", "configuration-changes"]
    retention: "log retention period"

# COMPLIANCE REQUIREMENTS
compliance:
  standards:
    - standard: "GDPR|HIPAA|SOX|PCI-DSS"
      requirements: ["specific requirements"]
      implementation: "compliance implementation strategy"
      
  data_governance:
    classification: "public|internal|confidential|restricted"
    retention: "data retention policies"
    deletion: "data deletion procedures"

# DISASTER RECOVERY
disaster_recovery:
  backup_strategy:
    frequency: "backup frequency"
    retention: "backup retention period"
    testing: "backup testing schedule"
    
  recovery_targets:
    rto: "Recovery Time Objective"
    rpo: "Recovery Point Objective"
    
  business_continuity:
    critical_functions: ["function1", "function2"]
    failover_strategy: "failover approach"

# ARCHITECTURE DECISIONS
decisions:
  - id: "AD-001"
    title: "Database Selection"
    status: "accepted|rejected|proposed"
    date: "YYYY-MM-DD"
    context: "decision context and background"
    decision: "what was decided"
    rationale: "why this decision was made"
    consequences: "positive and negative consequences"
    
# VALIDATION CRITERIA
validation:
  architecture_review:
    - "All requirements mapped to components"
    - "SOLID principles followed"
    - "Scalability targets achievable"
    - "Security requirements addressed"
    
  implementation_readiness:
    - "Component interfaces clearly defined"
    - "Technology choices validated"
    - "Development team understands design"
    - "Sufficient detail for implementation"

# NEXT PHASE HANDOFF
handoff_to_tdd:
  deliverables:
    - "Complete component specifications"
    - "Interface definitions for testing"
    - "Quality criteria and acceptance tests"
    - "Performance benchmarks for validation"
    
  success_criteria:
    - "TDD team understands architecture"
    - "Test strategy aligns with design"
    - "Implementation approach validated"
    - "Quality gates defined"

# METADATA
metadata:
  created_by: "architect name"
  created_date: "YYYY-MM-DD"
  last_updated: "YYYY-MM-DD"
  version: "1.0"
  approvals:
    - role: "Lead Architect"
      name: "approver name"
      date: "YYYY-MM-DD"
    - role: "Tech Lead"
      name: "approver name"
      date: "YYYY-MM-DD"
